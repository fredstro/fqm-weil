r"""
Subgroups of finite quadratic modules.


"""
import logging
from numbers import Rational

from sage.all import ZZ, QQ
from sage.arith.misc import prime_divisors, gcd, xgcd
from sage.categories.additive_groups import Groups
from sage.matrix.constructor import matrix
from sage.matrix.special import diagonal_matrix
from sage.misc.cachefunc import cached_method
from sage.misc.functional import is_odd
from sage.misc.latex import latex
from sage.misc.mrange import xmrange
from sage.modules.free_module_element import vector, Sequence
from sage.rings.integer import Integer

from .finite_quadratic_module_base import FiniteQuadraticModule_base
from .finite_quadratic_module_element import FiniteQuadraticModuleElement

log = logging.getLogger(__name__)

class FiniteQuadraticModule_subgroup(FiniteQuadraticModule_base):
    r"""
    Describes a subgroup of the underlying group of a finite quadratic module.


    EXAMPLES::

        sage: from fqm_weil.all import FiniteQuadraticModule, FiniteQuadraticModule_subgroup
        sage: p=FiniteQuadraticModule([2,3,10])
        sage: U = FiniteQuadraticModule_subgroup(p, (2*p.0 + 10*p.2,))
        sage: U.is_isotropic()
        True
        sage: p1 = U.quotient(); p1
        Finite quadratic module in 3 generators:
         gens: e0, e1, e2
         form: 3/20*x0^2 + 1/12*x1^2 + 1/10*x0*x2 + 1/10*x2^2
        sage: e0, e1, e2 = p1.gens()
        sage: V = p1.subgroup((e0+e1+e2,)); V
        < e0 + e1 + e2, 2*e1, 2*e2 >
        sage: W = V.dual(); W
        < e0 + 2*e2, 3*e1 + 5*e2 >
        sage: set([p1.B(x,y) for x in W.gens() for y in V.gens()])
        {0}
        sage: V.order(), W.order(), p1.order()
        (30, 4, 120)

        """

    Element = FiniteQuadraticModuleElement

    def __init__(self, ambient, gens, names="f", category=None):
        r"""
        Construct the subgroup generated by the list gens of
        elements of the quadratic module class.

        INPUT
            gens -- nonempty list of elements from the class quadratic module

        EXAMPLES::

            sage: from fqm_weil.all import FiniteQuadraticModule
            sage: from fqm_weil.all import FiniteQuadraticModule_subgroup
            sage: A=FiniteQuadraticModule('4^2.3.5')
            sage: FiniteQuadraticModule_subgroup(A,(A.0,A.1))
             < e0, e1 >
        """
        from .finite_quadratic_module_ambient import FiniteQuadraticModule_ambient
        if not isinstance(ambient, FiniteQuadraticModule_ambient):
            raise TypeError(
                f"ambient = {ambient} of type:{type(ambient)} must be a FiniteQuadraticModule_base instance.")
        if not isinstance(gens, tuple):
            raise TypeError(f"gens = {gens} must be a tuple")
        if Sequence(gens).universe() != ambient:
            raise TypeError
        self._ambient_gens = list(gens)
        self._ambient_gens.sort()
        self._ambient_group = ambient
        self._default_coords = 'canonical' #ambient._default_coords
        # Recall that we have two coordinates for the ambient QM
        # 1. canonical coordinates (essentially the input) - used for the parent abelian group
        # 2. fundamental system (hermite normal form and reduced coordinates)

        # We start by setting up the fundamental system generators:
        # self._init_fundamental_coordinates(gens, ambient)
        # save fun. coordinates of initializing list of gens as columns in the matrix __iMatrix
        # Is the below needed?
        # print("gens=",gens)
        # # throw out 0's, if list becomes empty set to [ambience(0)]
        # print("iMatrix=",self.__iMatrix)
        # print("lattice=",self.__lattice)
        # print("hnfmatrix=",self.__hnf_matrix)
        # print("hnf_gens=",self.__hnf_gens)
        # z = ambient(0)
        # if not self.__hnf_gens:
        #     self.__hnf_gens = [z]
        # print("hnf_gens=",self.__hnf_gens)
        # Now use the canonical coordinates to initialize canonical generators
        # print("gens=",gens)
        self._init_canonical_coordinates(gens, ambient)
        # print("ciMatrix=", self.__ciMatrix)
        # print("clattice=", self.__clattice)
        # print("chnfmatrix=", self.__can_matrix)
        # print("can_gens=", self.__can_gens)
        # if not self.__can_gens:
        #     self.__can_gens = [z]
        # print("can_gens=", self.__can_gens)
        # if self._default_coords == 'canonical':
        self._gens = self.__can_gens
        self._gens_matrix = self.__can_matrix
        self.__relations = self.__can_relations
        # else:
        #     self._gens = self.__hnf_gens
        #     self._gens_matrix = self.__hnf_matrix
        #     self.__relations = self.__hnf_relations

        self._ngens = len(self._gens)
        # print("self._hnf_gens=",self.__hnf_gens)
        # print("self._can_gens=", self.__can_gens)

        ambient_gram = ambient.gram(coords=self._default_coords)
        vector_gens = [vector(v.list(coords=self._default_coords)) for v in self._gens]
        G = matrix(QQ, [
                        [v.dot_product(ambient_gram * w) for v in vector_gens]
                        for w in vector_gens
                   ])
        G = FiniteQuadraticModule_base._reduce_mat(G)
        FiniteQuadraticModule_base.__init__(self, self.__relations, G, names=names,
                                            default_coords=self._default_coords)
        # # Reset the generators to the default coordinates.
        # if self._default_coords != 'canonical':
        #     self._gens = super(FiniteQuadraticModule_base, self).gens()
        #     self._ngens = len(self._gens)

    def _init_canonical_coordinates(self, gens, ambient):
        """
        Initialize subgroup with data in terms of the canonical coordinates.

        EXAMPLES::

            sage: from fqm_weil.all import FiniteQuadraticModule
            sage: F=FiniteQuadraticModule([2,3,10])
            sage: U = F.subgroup((F.0*30,))
            sage: U.gens_matrix()
            [ 2  0  0]
            [ 0  6  0]
            [ 0  0 20]
            sage: A.<a,b,c,d,e,f,g> = FiniteQuadraticModule('11^-7')
            sage: U = A.subgroup([a+b,b+c,c+d,d+e,e+f,f+g])
            sage: U.gens()
            (a + 10*g, b + g, c + 10*g, d + g, e + 10*g, f + g)
            sage: U.gens_matrix()
            [ 1  0  0  0  0  0  0]
            [ 0  1  0  0  0  0  0]
            [ 0  0  1  0  0  0  0]
            [ 0  0  0  1  0  0  0]
            [ 0  0  0  0  1  0  0]
            [ 0  0  0  0  0  1  0]
            [10  1 10  1 10  1 11]
        """
        self.__ciMatrix = matrix(ZZ, [gens[i].list(coords='canonical') for i in range(len(gens))]).transpose()
        # Get lattice generated by the columns of __iMatrix and the relations
        # of the ambient module.
        self.__clattice = self.__ciMatrix.column_module()
        self.__clattice += ambient.relations().column_module()
        self.__can_gens = [ambient(list(x), coords='canonical') for x in self.__clattice.matrix()]
        # Sort and remove trivial generators
        self.__can_gens = list(set([g for g in self.__can_gens if g.order() != 1]))
        self.__can_gens.sort()
        z = ambient(0)
        if not self.__can_gens:
            self.__can_gens = [z]
        self.__ngens_canonical = len(self.__can_gens)
        self.__can_matrix = self.__clattice.matrix().transpose()
        # Finally get the relations for this subgroup
        Hp = matrix(ZZ, [x.list(coords='canonical') for x in self.__can_gens]).transpose()
        Hp = Hp.augment(self.ambience().relations(coords='canonical'))
        Rp = matrix(ZZ, Hp.transpose().integer_kernel().matrix().transpose())
        R = Rp.matrix_from_rows(list(range(Rp.ncols())))
        self.__can_relations = R.transpose().echelon_form().transpose()

    def gen(self, i=0, coords=None):
        r"""
        Return generator no. i of this FQM subgroup.

        EXAMPLES::

            sage: from fqm_weil.all import FiniteQuadraticModule
            sage: F=FiniteQuadraticModule([2,3,10])
            sage: U = F.subgroup((F.0*30,))
            sage: U.gen(0)
            2*e0
            sage: A.<a,b,c,d>=FiniteQuadraticModule('2_1.4^2.3^1')
            sage: U = A.subgroup((a,b,c,d))
            sage: U.gen(0)
            a

        """
        # if coords == 'canonical':
        # return self.__can_gens[i]
        # if coords == 'hnf':
        #     return self.__hnf_gens[i]
        return self._gens[i]

    def ngens(self, coords=None):
        """
        Return the number of generators of self.

        Note: We need to redefine it here since the default should be the number of
        'canonical' generators as otherwise we might miss generators when splitting out
         the Sylow subgroups.

         EXAMPLES::

            sage: from fqm_weil.all import FiniteQuadraticModule
            sage: A.<a,b,c,d,e,f,h> = FiniteQuadraticModule('11^-3.2_2^4')
            sage: U = A.subgroup(A.gens())
            sage: U.ngens()
            7
            sage: U = A.subgroup(2)
            sage: U.ngens()
            4


        """
        if not coords:
            return self._ngens
        return super(FiniteQuadraticModule_subgroup, self).ngens(coords=coords)

    def __contains__(self, item):
        """
        Return True if item belongs to this FQM subgroup.

        EXAMPLES::

            sage: from fqm_weil.all import FiniteQuadraticModule
            sage: F=FiniteQuadraticModule([2,3,10])
            sage: U = F.subgroup((F.0*30,))
            sage: U.gen(0) in U
            True
            sage: F.0 in U
            False
            sage: 2*F.0 in U
            True
            sage: 0 in U
            False

        """
        if not isinstance(item, FiniteQuadraticModuleElement):
            return False
        if item.parent() is self:
            return True
        elif item in self.ambience():
            amb_inv = self.ambience().gens_orders()
            inv_basis = diagonal_matrix(ZZ, amb_inv)
            gens_basis = matrix(
                ZZ, len(self._gens), len(amb_inv),
                [g.lift() for g in self._gens]
            )
            return (vector(ZZ, item.lift())
                    in inv_basis.stack(gens_basis).row_module())
        return False

    ###################################
    # Iterators
    ###################################

    def __iter__(self):
        r"""
        Return a generator over the elements of self.

        TODO: More efficient implementation.

        EXAMPLES::

            sage: from fqm_weil.all import FiniteQuadraticModule
            sage: F=FiniteQuadraticModule([2,3,10])
            sage: U = F.subgroup((F.0*30,))
            sage: list(U)
            [0, 2*e0]
            sage: A.<a,b,c,d,e,f,g> = FiniteQuadraticModule('11^-7')
            sage: U = A.subgroup([a+b,b+c,c+d,d+e,e+f,f+g]); U
            < a + 10*g, b + g, c + 10*g, d + g, e + 10*g, f + g >
            sage: G = iter(U)
            sage: next(G)
            0
            sage: next(G)
            f + g

        """
        orders = [x.order() for x in self.gens()]
        for x in xmrange(orders):
            yield sum(g * x[i] for i, g in enumerate(self.gens()))

    ###################################
    # Introduce myself
    ###################################

    def _latex_(self):
        r"""
        LaTeX representation of this FQM subgroup.

        EXAMPLES::

        sage: from fqm_weil.all import FiniteQuadraticModule
        sage: F=FiniteQuadraticModule([2,3,10])
        sage: U = F.subgroup((F.0*30,))
        sage: latex(U)
        \langle 2 \cdot e0 \rangle

        """
        gens = ', '.join([latex(x) for x in self.gens()])
        return '\\langle %s \\rangle' % gens

    def _repr_(self):
        r"""
        String representation of this FQM subgroup.

        EXAMPLES::

        sage: from fqm_weil.all import FiniteQuadraticModule
        sage: F=FiniteQuadraticModule([2,3,10])
        sage: U = F.subgroup((F.0*30,))
        sage: U._repr_()
        '< 2*e0 >'
        sage: str(U)
        '< 2*e0 >'

        """
        gens = ', '.join([x._repr_() for x in self.gens()])
        return f'< {gens} >'

    ###################################
    # Providing struct. defining items
    ###################################

    def gens_matrix(self):
        r"""
        Return a matrix of generators of this subgroup with respect to a basis the ambient FQM.

        INPUT:

        - ``coords`` -- string (default None) either 'fundamental' or 'canonical'

        EXAMPLES::

            sage: from fqm_weil.all import FiniteQuadraticModule
            sage: A.<a,b,c,d>=FiniteQuadraticModule('2_1.4^2.3^1')
            sage: U = A.subgroup((a,b,c,d)); U
            < a, b, c, d >
            sage: U.gens_matrix()
            [1 0 0 0]
            [0 1 0 0]
            [0 0 1 0]
            [0 0 0 1]
            sage: F=FiniteQuadraticModule([2,3,10])
            sage: U = F.subgroup((F.0*30,F.1))
            sage: U.gens_matrix()
            [ 2  0  0]
            [ 0  1  0]
            [ 0  0 20]

        """
        return self._gens_matrix

    def ambience(self):
        r"""
        Return the ambient finite quadratic module.

        EXAMPLES::

            sage: from fqm_weil.all import FiniteQuadraticModule
            sage: A.<a,b,c,d>=FiniteQuadraticModule('2_1.4^2.3^1')
            sage: U = A.subgroup((a,b,c,d))
            sage: U.ambience() == A
            True

        """
        return self._ambient_group

    def _relations(self):
        r"""
        Return the relations relative to different coordinates for this FQM subgroup.

        EXAMPLES::

            sage: from fqm_weil.all import FiniteQuadraticModule
            sage: A.<a,b,c,d>=FiniteQuadraticModule('2_1.4^2.3^1')
            sage: U = A.subgroup((a,b,c,d)); U
            < a, b, c, d >
            sage: U._relations()
            [2 0 0 0]
            [0 4 0 0]
            [0 0 4 0]
            [0 0 0 3]
            sage: F=FiniteQuadraticModule([2,3,10])
            sage: U = F.subgroup((F.0*30,F.1))
            sage: U._relations()
            [2 0]
            [0 6]

        """
        return self.__relations

    def as_ambient(self, names=None):
        r"""
        Return a pair $B, f$, where $B$ is a finite quadratic module whose underlying
        group is isomorphic to self and whose quadratic form is
        the one induced by the ambient finite quadratic module $A$,
        and where $f: B \rightarrow A$ is the morphism of finite quadratic modules
        corresponding to the inclusion of self in $A$.

        EXAMPLES::

            sage: from fqm_weil.all import FiniteQuadraticModule
            sage: A = FiniteQuadraticModule(matrix(QQ, 2, [2,1,1,2]))
            sage: B = 2*A
            sage: a, b, c, d = B.gens()
            sage: U = B.subgroup([a+b])
            sage: C, f = U.as_ambient(); f
             Homomorphism : Finite quadratic module in 1 generator:
              gen: e
              form: 1/3*x^2 --> Finite quadratic module in 4 generators:
              gens: e1, e1, e3, e3
              form: 1/3*x0^2 + 2/3*x0*x1 + 1/3*x1^2 + 1/3*x2^2 + 2/3*x2*x3 + 1/3*x3^2
             e |--> e1
            sage: f(C.0)
            e1
            sage: F.<a,b>=FiniteQuadraticModule('4^2')
            sage: U = F.subgroup(()); U
            < 0 >
            sage: U.as_ambient()
            (Trivial finite quadratic module.,
             Homomorphism : Trivial finite quadratic module. --> Finite quadratic module in 2 generators:
              gens: a, b
              form: 1/4*x0*x1
             0 |--> 0)
            sage: R = matrix([[1,0],[10,21]])
            sage: G = matrix([[20/21,17/42],[17/42,17/21]])
            sage: F = FiniteQuadraticModule(R,G)
            sage: U = F.subgroup((F.1*3,))
            sage: U.as_ambient()
            (Finite quadratic module in 2 generators:
              gens: 4*e1, e1
              form: 4/7*x0^2 + 2/7*x0*x1 + 2/7*x1^2,
             Homomorphism : Finite quadratic module in 2 generators:
              gens: 4*e1, e1
              form: 4/7*x0^2 + 2/7*x0*x1 + 2/7*x1^2 --> Finite quadratic module in 2 generators:
              gens: 11*e1, e1
              form: 20/21*x0^2 + 17/21*x0*x1 + 17/21*x1^2
             4*e1 |--> 12*e1
             e1 |--> 3*e1)
        """
        from .finite_quadratic_module_ambient import FiniteQuadraticModule_ambient
        B = FiniteQuadraticModule_ambient(self.relations(), self.gram(), names=names)
        f = B.hom(tuple(self.ambience()(x) for x in self.gens()))
        return B, f

    # def Q(self, x):
    #     ambient, phi = self.as_ambient()
    #     return ambient.Q(phi(x))
    #
    # def B(self, x, y):
    #     ambient, phi = self.as_ambient()
    #     return ambient.B(phi(x), phi(y))

    ###################################
    # Associated quantities
    ###################################

    def order(self):
        r"""
        Return the order of this subgroup.

        EXAMPLES NONE

        """
        return Integer(self.ambience().order() / self.gens_matrix().determinant(proof=False))

    def level(self):
        r"""
        Return the level of this subgroup (viewed as quadratic module w.r.t.
        to the quadratic form inherited from its ambient module).

        EXAMPLES NONE
        """
        n = self.ngens()
        gens = self.gens()
        v = [x.norm() for x in gens]
        w = [gens[i].dot(gens[j]) for i in range(n) for j in range(i + 1, n)]
        return vector(v + w).denominator()

    ###################################
    # Operations
    ###################################

    def dual(self):
        r"""
        Return the dual subgroup in the ambient module.

        EXAMPLES NONE
        """
        return self.ambience().dual_subgroup(self)

    def __add__(self, other):
        r"""
        Return the sum of this module and the other.

        EXAMPLES NONE
        """
        if isinstance(other, FiniteQuadraticModule_base):
            return FiniteQuadraticModule_subgroup(self._ambient_group,
                                              tuple(self.gens() + other.gens()))
        if isinstance(other, FiniteQuadraticModuleElement):
            return [x + other for x in self]
        raise ValueError("Can only add subgroups or an element")

    def _mul_(self, other):
        r"""
        Return this module times other.

        EXAMPLES NONE
        """
        if not isinstance(other, (Integer, Rational)):
            raise ValueError("Scalar multiplication is only defined for integers.")
        a = other.numerator()
        c = other.denominator()
        if c != 1 and a != 1:
            return self._mul_(a).___truediv__(c)
        if a == 1:
            return self.__truediv__(c)
        if gcd(self.order(), a) == 1:
            return self
        gens = [x*a for x in self.gens()]
        return FiniteQuadraticModule_subgroup(self._ambient_group, tuple(gens))

    def __truediv__(self, other):
        r"""
        Return this subgroup divided by other as a subgroup of the ambient group.

        If other is a scalar return the group {y | y*other in self}
        Otherwise, if other is a subgroup of self  return self / other

        Note: We use a brute-force algorithm.

        EXAMPLES NONE
        """
        if other == 0:
            return FiniteQuadraticModule_subgroup(self._ambient_group, self._ambient_group.gens())
        if isinstance(other, Integer):
            gens = [x for x in self.ambience() if other*x in self]
            return FiniteQuadraticModule_subgroup(self._ambient_group, tuple(gens))
        if not isinstance(other, FiniteQuadraticModule_subgroup) or not other.is_subgroup(self):
            raise ValueError("Can only divide by a subgroup of this group.")
        # find a set of generators of self mod other
        gens = [self.ambience()(0)]
        for g in self.gens():
            is_independent = True
            for g1 in gens:
                if g - g1 in other:
                    is_independent = False
                    break
            if is_independent:
                gens.append(g)
        return self.ambience().subgroup(gens)

    def cap(self, V):
        r"""
        Return the intersection of this subgroup with the subgroup $V$.

        EXAMPLES::

            sage: from fqm_weil.all import FiniteQuadraticModule
            sage: A.<a,b,c,d> = FiniteQuadraticModule('3^-4')
            sage: U = A.subgroup([a+b,c])
            sage: V = A.subgroup([a+b,d])
            sage: W = U.cap(V); W
            < a + b >

            sage: A.<a,b,c,d> = FiniteQuadraticModule('2_2^-4'); A
            Finite quadratic module in 4 generators:
             gens: a, b, c, d
             form: 1/4*x0^2 + 3/4*x1^2 + 3/4*x2^2 + 3/4*x3^2
            sage: U = A.subgroup([a,b])
            sage: V = U.dual(); V
            < c, d >
            sage: U.cap(V)
            < 0 >
        """
        if not isinstance(V, FiniteQuadraticModule_subgroup):
            raise ValueError("Need object of type FiniteQuadraticModule_subgroup")
        ambience = self.ambience()
        # print(f"Check equality of {ambience} {type(ambience)} and {V.ambience()} {(type(V.ambience()))}")
        if ambience != V.ambience():
            raise ValueError(f"Input need same ambient module. ")
                    # f"Got:{V.ambience()} ({V.ambience().variable_names()}instead of "\
                    # f"{self.ambience()} ({V.ambience().variable_names() == self.ambience().variable_names()})"
                    # f"{V.ambience().gram() == ambience.gram()}"\
                    # f"{V.ambience().relations() == ambience.relations()}"\
                    #          )
        #lat0 = diagonal_matrix(ZZ, list(ambience.elementary_divisors())).column_module()
        lat0 = ambience.relations(coords=self._default_coords).column_module()
        lat1 = self.gens_matrix().column_module() + lat0
        lat2 = V.gens_matrix().column_module() + lat0
        lat = lat1.intersection(lat2)
        return ambience.subgroup([ambience(list(x), coords=self._default_coords)
                                  for x in lat.matrix()])

    def quotient(self):
        r"""
        If this is $U$ and the ambient module $A$ then return $A/U$.

        EXAMPLES NONE
        """
        return self.ambience().quotient(self)

    def split(self, n):
        r"""
        Return the splitting $U+V$ of this subgroup
        where the exponent of $U$ divides $n^\infty$ and the exponent of
        $V$ is relatively prime to $n$.

        INPUT
            n -- an integer

        NOTE
            $U$ and $V$ are orthogonal to each other.
            If $n$ is a prime then $U$ is the Sylow $p$-subgroup of self.

        EXAMPLES::

            sage: from fqm_weil.all import FiniteQuadraticModule
            sage: A.<a,b,c,d,e,f,g,h,j> = FiniteQuadraticModule('23^4.2_2^4.3'); A
            Finite quadratic module in 9 generators:
             gens: a, b, c, d, e, f, g, h, j
             form: 1/23*x0^2 + 1/23*x1^2 + 1/23*x2^2 + 1/23*x3^2 + 1/4*x4^2 + 1/4*x5^2 + ...
            sage: U = A.subgroup(A.gens()); U
            < a, b, c, d, e, f, g, h, j >
            sage: U.split(2)
            (< e, f, g, h >, < a, b, c, d, j >)
            sage: A.<a,b,c,d> = FiniteQuadraticModule('23^4.2_2^4.3', \
            ....: default_coords='fundamental'); A
            Finite quadratic module in 4 generators:
             gens: a, b, c, d
             form: 27/92*x0^2 + 27/92*x1^2 + 73/92*x2^2 + 265/276*x3^2
            sage: U = A.subgroup(A.gens()); U
            < 23*a, 22*a, 23*b, 22*b, 23*c, 22*c, 114*d, 69*d, 46*d >
            sage: U2 = U.split(2); U2
             (< 23*a, 23*b, 23*c, 69*d >, < 22*a, 22*b, 22*c, 114*d, 46*d >)
            sage: U3 = U.split(3); U3
             (< 46*d >, < 23*a, 22*a, 23*b, 22*b, 23*c, 22*c, 114*d, 69*d >)
            sage: U23 = U.split(23); U23
             (< 22*a, 22*b, 22*c, 114*d >, < 23*a, 23*b, 23*c, 69*d, 46*d >)
            sage: V = U2[0] + U3[0] + U23[0]
            sage: U == V
            True
            sage: U is V
            False
            sage: A.<a,b,c,d> = FiniteQuadraticModule('11^-3.2_2^4', default_coords='fundamental')
            sage: U = A.subgroup(A.gens())
            sage: A2 = U.split(2)[0]; A2
            < a, 11*b, 11*c, 11*d >


        """
        # Let e be the exponent of self, write e=e1e2 with gcd(e1,n)=1, e2 | n^infty,
        # choose x, y such that 1 = e1x+e2y, set u=e1x and v=e2y. If a in A,
        # then a = u*a + v*a is the decomposition of a with respect to self = U + V.
        # In fact, if q dnotes the order of a, let q=q1q2 with gcd(q1,n)=1, q2 | n^infty.
        # Then the order of u*a is q/gcd(q,u) = q/gcd(q,e1x) = q/q1 = q2, and
        # the order of v*a is q/gcd(q,v) = = q/gcd(q,e2y) = q/q2 = q1.
        e = self.level()
        e2 = gcd(e, n)
        e1 = Integer(e / e2)
        while not 1 == e1.gcd(e2):
            n = n ** 2
            e2 = gcd(e, n)
            e1 = Integer(e / e2)
        g, x, y = xgcd(e1, e2)
        u = x * e1
        v = y * e2
        ul = []
        vl = []
        for a in self.gens():
            ul.append(u * a)
            vl.append(v * a)
        return FiniteQuadraticModule_subgroup(self._ambient_group, tuple(ul)), \
               FiniteQuadraticModule_subgroup(self._ambient_group, tuple(vl))

    ###################################
    # Predicates
    ###################################

    def is_multiplicative(self):
        r"""
        EXAMPLES NONE
        """
        return False

    def is_isotropic(self):
        r"""
        EXAMPLES NONE
        """
        return 1 == self.level()

    ###################################
    # Relations
    ###################################

    def __lt__(self, other):
        return self.__le(other) and not self == other

    def __le__(self, other):
        return self._divides(other.gens_matrix(), self.gens_matrix())

    def __eq__(self, other):
        if not isinstance(other, FiniteQuadraticModule_subgroup):
            return False
        return super(FiniteQuadraticModule_subgroup, self).__eq__(other)

    def __ne__(self, other):
        return self.gens_matrix() != other.gens_matrix()

    def __gt__(self, other):
        return self.__ge(other) and not self == other

    def __ge__(self, other):
        r"""
        EXAMPLES NONE
        Test here all of the above
        """
        return self._divides(self.gens_matrix(), other.gens_matrix())

    # def __contains__(self, item):
    #     if item in self.ambience()
    ###################################
    # Misc
    ###################################

    def orthogonal_basis(self, check=True):
        r"""
        Return an orthogonal system for this subgroup
        if this subgroup is nondegenerate
        w.r.t. the scalar product induced from the ambient module.
        Otherwise raise an exception.

        NOTE:
            An orthonormal system for a subgroup is a system of pairwise
            orthogonal generators $a_i$ of $p$-order, possibly extended by pairs
            of generators $b_j,c_j$ which are orthogonal to the $a_i$ and such that
            the subgroups $\langle b_j,c_j \rangle$ are pairwise orthogonal and do no possess
            orthogonal generators.

        EXAMPLES::

            sage: from fqm_weil.all import FiniteQuadraticModule
            sage: A.<a,b,c,d,e,f,g> = FiniteQuadraticModule('11^-7')
            sage: U = A.subgroup([a+b,b+c,c+d,d+e,e+f,f+g]); U
            < a + 10*g, b + g, c + 10*g, d + g, e + 10*g, f + g >
            sage: matrix(len(U.gens()), [x.dot(y) for x in U.gens() for y in U.gens()])
            [4/11 9/11 2/11 9/11 2/11 9/11]
            [9/11 4/11 9/11 2/11 9/11 2/11]
            [2/11 9/11 4/11 9/11 2/11 9/11]
            [9/11 2/11 9/11 4/11 9/11 2/11]
            [2/11 9/11 2/11 9/11 4/11 9/11]
            [9/11 2/11 9/11 2/11 9/11 4/11]
            sage: og_b = U.orthogonal_basis(); og_b
             [a + 6*b + c + 10*d + e + 10*f + g,
             a + 6*c + 10*d + e + 10*f + g,
             a + 4*d + e + 10*f + g,
             a + 8*e + 10*f + g,
             a + 2*f + g,
             a + 10*g]
             sage: matrix(len(og_b), [x.dot(y) for x in og_b for y in og_b])
             [7/11    0    0    0    0    0]
             [   0 5/11    0    0    0    0]
             [   0    0 7/11    0    0    0]
             [   0    0    0 2/11    0    0]
             [   0    0    0    0 1/11    0]
             [   0    0    0    0    0 4/11]
        """
        if not self.as_ambient()[0].is_nondegenerate():
            raise TypeError
        pl = prime_divisors(self.order())
        og_b = []
        V = self
        while pl != []:
            p = pl.pop()
            if pl != []:
                U, V = V.split(p)
            else:
                U = V
            og_b += U._orthogonal_basis()
        if check:
            # For odd order we check that the gram matrix is diagonal.
            if is_odd(self.order()):
                n = len(og_b)
                m = matrix(QQ, n, n, [[self.ambience().B(x, y) for x in og_b] for y in og_b])
                assert m.is_diagonal()
        # Sort the basis elements according to the vector representation
        og_b.sort()
        return og_b

    def _orthogonal_basis(self, check=False):
        r"""
        See FiniteQuadraticModule_subgroup.orthogonal_basis().
        Apply only for nondegenerate $p$-groups.
        Do not use this method directly, you may run in an infinite
        loop for degenerate subgroups. Use orthogonal_basis()
        instead.

        .. NOTE:
            The proof that the algorithm implemented here works as
            follows (see also [Sko]): Let $U$ be a $p$-subgroup of a
            quadratic module $A$ such that the scalar product of
            $A$ induces a nondegenerate on $U$. The value subgroup,
            i.e. the subgroup generated by the values $B(x,y)$ ($x,y$
            in $U$), is (as every subgroup of $\QQ/\ZZ$) cyclic,
            hence generated by a fixed value $B(x,y)$. We may assume
            that $x$ and $y$ are in $U.gens()$ (since $B(x,y)$ being
            a generator is equivalent to the statement that $B(x,y)$
            has the largest denominator among all values).  If $x=y$
            then $U = \langle x \rangle + V$, where $V$ is the dual of
            $\langle x \rangle$ in $U$: in fact, $z - tx$, with an
            integer $t$ such that $B(z,x) = tB(x,x)$, is in $V$ for
            every $z$ in $U$. Assume now that $x != y$ and $B(z,z)$
            never generates the value subgroup for some $z$ in
            $U.gens()$.  Then there are two cases. If $p$ is odd then
            $B(x+y,x+y)$ generates the value subgroup and we can do
            the same argument as before with $x$ replaced by $x+y$.
            However, if $p=2$ then $U = \langle x,y \rangle + V$,
            where $V$ is the orthogonal complement of $\langle x,y
            \rangle$ in $U$. Namely, if $z$ in $U$ then we can find
            integers $t$ and $s$ such that $z - tx -sy$ is in $V$,
            i.e. such that $B(z,x) = t B(x,x) - s B(x,y)$ and $B(z,y)
            = t B(x,y) - s B(y,y)$. Since $U$ is nondegenerate we know
            that the sums here are all direct (since $|X||Y| = |U|$
            for any subgroup $X$ in $U$ with $Y$ denoting its
            dual). But then $V$ is nondegenerate too and we can
            proceed by induction.

        .. WARNING:
            This algorithm does not produce an orthogonal basis for certain 2-adic components.
            For instance for '2^2' we have D=Z/2Z x Z/2Z and the gram matrix [[0,1/4],[1/4,0]]
            and this algorithm would simply return (1,0),(0,1) as a "canonical basis".
        """
        if self.order() == 1:
            return []
        if self.ngens() == 1:
            return [self.gen(0)]
        g = self.gens()
        og_b = []
        d = 0
        for x in g:
            e = x.dot(x).denominator()
            log.debug(f"Q({x})={x.dot(x)}")
            if e > d:
                d = e
                og_b = [x]
        log.debug(f"og_b0={og_b}")
        for i, x in enumerate(g):
            for y in g[i + 1:]:
                e = x.dot(y).denominator()
                log.debug(f"B({x},{y})={x.dot(y)}")
                if e > d:
                    d = e
                    if is_odd(d):
                        og_b = [x+y]
                    else:
                        # for modules with symbols 2^2 and 2^-2 there is no orthogonal basis.
                        og_b = [x, y]
        log.debug(f"og1={og_b}")
        if og_b is None:
            raise ArithmeticError("Could not find an orthogonal basis.")
        V = self.cap(self.ambience().subgroup(og_b).dual())
        og_v = V._orthogonal_basis()
        log.debug(f"ogV={og_v}")
        og_b = og_b + og_v
        log.debug(f"og2={og_b}")
        og_b = list(set(og_b))
        return og_b

    ###################################
    # Auxiliary functions
    ###################################

    @staticmethod
    def _normal_form(gens):
        r"""
        Assuming that $gens = [x,y]$ and $x$ and $y$ span a type II quadratic module
        return a normalized basis $u$, $v$ for the subgroup generated by $x$ and $y$,
        i.e. generators such that either $x.norm() = x.dot(y) = y.norm()$ or
        $x.norm() = y.norm() = 0$ and $x.dot(y) =1/2^n$.
        TODO: Implement
        """
        raise NotImplementedError("To be implemented!")
        # M = matrix([x.norm()])
        pass
